# 实验报告：HarmonyOS ArkTS 商品列表页面实现

## 一、项目背景与目标
本项目旨在在 HarmonyOS ArkTS 环境下，构建一套高性能、体验友好的多功能商品浏览页面，满足移动端主流电商的核心交互需求。

主要目标：
- 支持商品浏览（双列瀑布流，高矮图混排，含缩略图/关键词/价格），兼容不同屏幕尺寸，提升信息密度与视觉美观。
- 分类 Tab 三步直达（点 Tab → 看子类 → 浏览商品），优化用户查找路径，减少操作步骤。
- 搜索与多条件筛选（关键词、分类/子类、价格区间、排序），实现复杂业务场景下的高效收敛。
- 下拉刷新、懒加载、到底提示与回弹效果，提升数据交互流畅度与用户反馈。
- 组件选型基于 ArkUI 提供的 Scroll/List/LazyForEach/EdgeEffect，结合自定义刷新容器，兼顾性能与可扩展性。

项目强调数据驱动、响应式架构、分层解耦，便于后续维护和功能拓展。

## 二、技术方案与组件选择
本项目采用分层与组件化技术方案，兼顾性能、体验与可维护性：

- Scroll：承载页面可滚动主体（Tabs + 列表），支持绑定 EdgeEffect(Spring) 获得系统弹簧回弹，提升到底体验。
- List / LazyForEach：用于长列表懒加载，结合瀑布流分桶，既保证性能又兼容 Masonry 布局。
- 自定义 RefreshLayout：基于 TouchEvent 计算下拉位移，超阈值渲染刷新提示，刷新回调带超时兜底，防止 UI 卡死。
- EdgeEffect(Spring)：利用系统级回弹，到底时自然弹回，减少自定义动画开发与兼容性问题。
- AdvancedListDataSource：集中管理全量商品、筛选条件（关键词、分类/子类、价格区间、排序），负责 applyFilters 与 loadMore，保证数据流清晰、易于扩展。

此外，项目采用 @Provide/@Consume 注解实现响应式数据流，组件间解耦，极大提升了开发效率和代码可维护性。

## 三、核心业务实现细节
### 1) 商品浏览（双列瀑布流、高矮图共存）

本项目采用自定义 WaterfallList 组件实现双列瀑布流布局，兼容高矮图片混排，具体实现如下：

#### 1.1 数据分桶与渲染流程
核心思想是将商品数据按索引奇偶分为左右两列，分别渲染，保证 Masonry 效果。

```typescript
// WaterfallList.ets 片段
@Component
struct WaterfallList {
  @Consume('goodsDS') goodsDS: AdvancedListDataSource;
  build() {
    let left = this.goodsDS.filteredGoods.filter((_, idx) => idx % 2 === 0);
    let right = this.goodsDS.filteredGoods.filter((_, idx) => idx % 2 === 1);
    Row() {
      Column() {
        ForEach(left, (item) => {
          GoodsCard({ goods: item })
        })
      }
      Column() {
        ForEach(right, (item) => {
          GoodsCard({ goods: item })
        })
      }
    }
  }
}
```
如上，`filteredGoods` 为已筛选商品，分桶后分别用 ForEach 渲染，保证高矮图自然交错。

#### 1.2 商品卡片内容
每个商品卡片展示图片、名称、广告语、价格等，支持后续扩展。

```typescript
// GoodsCard.ets 片段
@Component
struct GoodsCard {
  @Prop goods: Goods;
  build() {
    Column() {
      Image(this.goods.imageUrl).objectFit(ImageFit.Cover)
      Text(this.goods.name)
      Text(this.goods.ad)
      Text('￥' + this.goods.price)
    }
  }
}
```
图片采用 Cover 裁切，保证缩略图统一，信息层次分明。

#### 1.3 数据驱动与响应式
WaterfallList 通过 @Consume 注入数据源，任何筛选/搜索/懒加载都会自动刷新列表。

```typescript
// 注入数据源，响应式刷新
@Consume('goodsDS') goodsDS: AdvancedListDataSource;
```
这样，外部如 Tab 切换、搜索、loadMore 只需操作数据源，瀑布流自动响应。

#### 1.4 设计理由与难点
- 采用奇偶分桶，代码简洁，能保证高矮图混排的视觉均衡。
- 若需进一步优化列高平衡，可扩展为动态分桶（遍历累加高度分配）。
- 响应式数据流简化了组件间通信，提升了可维护性。

---
### 2) 分类 Tab（三步直达）

本项目通过 TabBarsComponent 实现“点 Tab → 看子类 → 浏览商品”的三级导航体验，核心实现如下：

#### 2.1 Tabs 与子类动态渲染
TabBarsComponent 维护当前大类与子类状态，切换 Tab 时自动刷新子类按钮与商品列表。

```typescript
// TabBarsComponent.ets 片段
@Component
struct TabBarsComponent {
  @Consume('homeDS') homeDS: AdvancedListDataSource;
  @State currentTab: number = 0;
  @State currentSub: number = 0;
  build() {
    Tabs({
      index: this.currentTab,
      onChange: (idx) => {
        this.currentTab = idx;
        this.currentSub = 0;
        this.homeDS.setCategory(idx, 0); // 切换大类，重置子类
        this.scroller.scrollTo(0, 0); // 滚动回顶部
      }
    })
    Row() {
      ForEach(this.homeDS.getSubCategories(this.currentTab), (sub, subIdx) => {
        Button(sub.name, {
          onClick: () => {
            this.currentSub = subIdx;
            this.homeDS.setCategory(this.currentTab, subIdx);
          }
        })
      })
    }
    // ...商品列表与刷新逻辑...
  }
}
```
Tabs 切换时重置子类与滚动，子类按钮动态渲染，点击后立即筛选商品。

#### 2.2 状态同步与数据流
Tab 切换、子类切换均通过 homeDS 数据源的 setCategory 方法驱动，保证筛选与 UI 同步。

```typescript
// 数据源筛选
setCategory(catId: number, subId: number) {
  this.filter.category = catId;
  this.filter.subCategory = subId;
  this.applyFilters();
}
```
每次切换都会触发 applyFilters，刷新 filteredGoods，瀑布流自动响应。

#### 2.3 设计理由与交互体验
- 三级导航（Tab→子类→商品）路径清晰，用户可一步步收敛目标。
- 滚动重置与状态同步，避免切换后内容错位。
- 数据驱动，UI 与业务逻辑解耦，便于维护和扩展。

---
### 3) 搜索与多条件筛选

本项目支持关键词、分类/子类、价格区间、排序等多条件叠加筛选，核心逻辑集中在 AdvancedListDataSource。

#### 3.1 搜索与筛选链路
每次输入关键词、切换分类、调整价格区间或排序，都会调用 applyFilters，链式组合所有条件。

```typescript
// AdvancedListDataSource.ets 片段
applyFilters() {
  let result = this.allGoods;
  // 关键词过滤
  if (this.filter.keyword) {
    result = result.filter(g => g.name.includes(this.filter.keyword) || g.keywords.some(k => k.includes(this.filter.keyword)));
  }
  // 分类/子类过滤
  if (this.filter.category !== undefined) {
    result = result.filter(g => g.categoryId === this.filter.category);
    if (this.filter.subCategory !== undefined) {
      result = result.filter(g => g.subCategoryId === this.filter.subCategory);
    }
  }
  // 价格区间
  if (this.filter.priceMin !== undefined) {
    result = result.filter(g => g.price >= this.filter.priceMin);
  }
  if (this.filter.priceMax !== undefined) {
    result = result.filter(g => g.price <= this.filter.priceMax);
  }
  // 排序
  if (this.filter.sort === 'asc') {
    result = result.sort((a, b) => a.price - b.price);
  } else if (this.filter.sort === 'desc') {
    result = result.sort((a, b) => b.price - a.price);
  }
  this.filteredGoods = result;
}
```
所有筛选条件链式组合，保证结果唯一且高效。

#### 3.2 懒加载与分页
loadMore 方法基于 filteredGoods 切片追加，防止越界和重复。

```typescript
// AdvancedListDataSource.ets 片段
loadMore() {
  let next = this.filteredGoods.slice(0, this.currentLength + this.MAX_DATA_LENGTH);
  this.currentLength = next.length;
  this.displayGoods = next;
}
```
每次上滑触发 loadMore，逐步扩展显示商品。

#### 3.3 设计理由与难点
- 筛选链路集中，便于维护和扩展。
- 懒加载基于过滤结果，避免重复和越界。
- 支持多条件叠加，满足复杂业务需求。

---
### 4) 下拉刷新、到底提示与回弹

本项目自定义 RefreshLayout 组件实现下拉刷新，结合 EdgeEffect.Spring 获得系统级回弹。

#### 4.1 下拉刷新逻辑
RefreshLayout 监听 TouchEvent，计算下拉位移，超阈值后渲染刷新提示，触发刷新回调。

```typescript
// RefreshLayout.ets 片段
@Component
struct RefreshLayout {
  @Prop onRefresh: () => Promise<void>;
  @State pulling: boolean = false;
  @State refreshing: boolean = false;
  @State offsetY: number = 0;
  build() {
    Scroll({
      onTouch: (event) => {
        if (event.type === TouchType.Down) {
          this.startY = event.y;
        } else if (event.type === TouchType.Move) {
          this.offsetY = event.y - this.startY;
          this.pulling = this.offsetY > this.triggerOffset;
        } else if (event.type === TouchType.Up) {
          if (this.pulling) {
            this.refreshing = true;
            this.onRefresh().finally(() => {
              this.refreshing = false;
              this.offsetY = 0;
            });
          } else {
            this.offsetY = 0;
          }
        }
      }
    })
    if (this.pulling || this.refreshing) {
      PutDownRefresh()
    }
  }
}
```
超时保护通过 Promise + setTimeout 实现，防止刷新卡死。

#### 4.2 到底提示与回弹
Scroll 组件开启 EdgeEffect.Spring，到底时自动弹回，底部渲染“已到底了”提示。

```typescript
// TabBarsComponent.ets 片段
Scroll({
  edgeEffect: EdgeEffect.Spring,
  // ...
})
if (已到底) {
  Text('已到底了')
}
```

#### 4.3 设计理由与体验优化
- 自定义刷新容器，交互流畅，兼容多种业务场景。
- 系统回弹效果，减少自定义动画开发。
- 超时兜底，提升健壮性。

## 四、架构设计与数据流
本项目采用分层架构，核心分为数据层、视图层、交互层，各层解耦、职责清晰。

### 4.1 数据层（AdvancedListDataSource）
负责全量商品数据、筛选条件、懒加载分页、过滤逻辑的集中管理。

主要属性与方法：
- `allGoods`：全量商品数组，初始化时加载。
- `filter`：包含关键词、分类/子类、价格区间、排序等所有筛选条件。
- `filteredGoods`：当前所有筛选条件作用后的商品结果。
- `displayGoods`：当前实际渲染到页面的商品（支持懒加载分页）。
- `applyFilters()`：链式组合所有筛选条件，实时更新 `filteredGoods`。
- `loadMore()`：在 `filteredGoods` 基础上分页追加，更新 `displayGoods`。

数据层通过 `@Provide` 注解向视图层暴露，保证响应式更新。

### 4.2 视图层
负责页面结构、UI 组件组织、状态响应。

- `TabBarsComponent`：顶层容器，组织 Tabs、子类按钮、WaterfallList、RefreshLayout，处理 Tab 切换、子类切换、滚动重置。
- `WaterfallList`：双列瀑布流渲染，消费数据层的 `filteredGoods`，按奇偶分桶，动态响应数据变化。
- `RefreshLayout`：自定义下拉刷新容器，封装下拉交互、刷新提示、超时保护。
- 其他如 `GoodsCard`、`SearchAndFilterBar` 等，分别负责商品卡片渲染、搜索/筛选入口。

各组件通过 `@Consume` 注解获取数据源，保证数据驱动视图，状态变更自动刷新。

### 4.3 交互层
负责用户输入、事件响应、业务逻辑触发。

- `SearchAndFilterBar`：负责关键词输入、排序/筛选条件选择，调用数据层方法实时过滤。
- `TabBarsComponent`：Tabs/子类切换时，调用数据层 `setCategory`，并重置滚动。
- `RefreshLayout`：下拉触发刷新回调，刷新后自动收起刷新态。

#### 4.4 典型数据流与响应链
1. 用户切换 Tab → `TabBarsComponent` 调用 `setCategory` → 数据层更新 filter 并 applyFilters → `filteredGoods` 变化 → `WaterfallList` 自动刷新。
2. 用户输入关键词/筛选 → `SearchAndFilterBar` 调用数据层方法 → applyFilters → 视图层自动响应。
3. 用户下拉刷新 → `RefreshLayout` 触发回调 → 数据层重新拉取/重置数据 → 视图层刷新。

这种分层+响应式数据流设计，保证了高内聚、低耦合，便于维护和扩展。

## 五、关键实现要点
本节针对项目中的关键技术点，结合实际代码片段，详细说明设计思路、难点与优化。

### 5.1 Masonry 瀑布流分桶与渲染
实现思路：将商品数据按索引奇偶分为左右两列，分别渲染，保证高矮图混排的 Masonry 效果。
难点与优化：
- 简单奇偶分桶实现高效，但列高可能不完全均衡。若需进一步优化，可遍历累加高度动态分配。
代码片段：
```typescript
let left = goods.filter((_, idx) => idx % 2 === 0);
let right = goods.filter((_, idx) => idx % 2 === 1);
Row() {
  Column() { ForEach(left, ...) }
  Column() { ForEach(right, ...) }
}
```

### 5.2 多条件过滤链路
实现思路：所有筛选条件（关键词、分类、子类、价格区间、排序）链式组合，保证结果唯一且高效。
难点与优化：
- 需保证每次筛选都能实时响应 UI，避免重复计算。
代码片段：
```typescript
applyFilters() {
  let result = this.allGoods;
  // ...依次过滤...
  this.filteredGoods = result;
}
```

### 5.3 懒加载与分页
实现思路：loadMore 基于 filteredGoods 切片追加，限制 MAX_DATA_LENGTH，避免重复和越界。
难点与优化：
- 需处理好分页边界，防止越界和重复渲染。
代码片段：
```typescript
loadMore() {
  let next = this.filteredGoods.slice(0, this.currentLength + this.MAX_DATA_LENGTH);
  this.currentLength = next.length;
  this.displayGoods = next;
}
```

### 5.4 下拉刷新与超时兜底
实现思路：TouchEvent 记录起止 y，超 offset 展示刷新提示，刷新 Promise + setTimeout 兜底，最终收起刷新态。
难点与优化：
- 需防止网络异常导致刷新状态悬挂，保证 UI 可恢复。
代码片段：
```typescript
onTouch: (event) => {
  // ...下拉逻辑...
  if (this.pulling) {
    this.refreshing = true;
    Promise.race([
      this.onRefresh(),
      new Promise(resolve => setTimeout(resolve, 3000))
    ]).finally(() => {
      this.refreshing = false;
      this.offsetY = 0;
    });
  }
}
```

### 5.5 滚动重置与状态同步
实现思路：Tab onChange 时调用 Scroller.scrollTo(0,0)，并重置子类选中与数据源筛选状态。
难点与优化：
- 需保证切换后内容与筛选状态同步，避免 UI 错位。
代码片段：
```typescript
onChange: (idx) => {
  this.currentTab = idx;
  this.currentSub = 0;
  this.homeDS.setCategory(idx, 0);
  this.scroller.scrollTo(0, 0);
}
```

## 六、角色分工与工作说明
本项目采用小组协作开发，分工明确，采用代码评审与持续集成保障质量。

- 23355032 赖鼎昭：负责商品浏览体验（缩略图、关键词、首页瀑布流、高矮图共存），主导卡片样式与图片裁切，参与 UI 细节优化。
- 23322058 谭瀚威：负责分类 Tab 三步流程（Tab→子类→列表）、页面整体渲染与状态重置逻辑，主导页面结构设计。
- 23336127 梁皓明：负责搜索与筛选（关键词匹配、排序、叠加过滤条件、价格区间）、过滤链路稳定性，参与数据层优化。
- 23336088 胡明瀚：负责下拉刷新、懒加载、到底提示与 EdgeEffect 回弹，主导刷新超时保护与性能体验优化。

## 七、结论
本项目基于 HarmonyOS ArkTS 组件体系，系统性实现了商品列表的核心业务与交互，包括下拉刷新、懒加载、到底提示、多维筛选、分类导航与瀑布流展示，整体达到预期需求。

项目在架构设计、数据流管理、用户体验、性能优化等方面均做到了工程化、模块化和高可维护性。通过分层解耦、响应式数据驱动、组件化复用，极大提升了开发效率和代码质量。各项功能经过充分测试，兼容性和健壮性良好，能够适应多种业务场景和终端环境。

团队协作高效，分工明确，采用代码评审和持续集成保障了项目质量。整体开发过程体现了现代前端工程的最佳实践。

本项目不仅实现了预期的业务目标，也为后续功能扩展和性能提升打下了坚实基础，具备良好的工程落地和推广价值。